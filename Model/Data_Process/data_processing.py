# -*- coding: utf-8 -*-
"""Data_Processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z_pBda75ham8VFdb2plBPSOQK2gVKpuW
"""

import torch
import cv2
import os
import numpy as np
import shutil
from google.colab.patches import cv2_imshow
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
import math
from PIL import Image
import torch.nn as nn
import yaml
import random
from google.colab import files
import sys
import time
from torch.utils.data import random_split
# from Model.functions.functions import *
# from Model.Model1.model1_script import *

'''
# shuffle dataset
start_time = time.time()
how_many_times = 1000
for count in range(how_many_times):
    ori_data_path = '/content/drive/MyDrive/Colab Notebooks/Simple_DE/Data/data_zip_shuffle'
    ori_name_path = '/content/drive/MyDrive/Colab Notebooks/Simple_DE/Data/name_zip_shuffle'

    ori_data_path_list = sorted(os.listdir(ori_data_path))
    ori_name_path_list = sorted(os.listdir(ori_name_path))
    ori_length = len(ori_data_path_list)

    # path = os.path.join(ori_data_path, ori_data_path_list[0])
    random_number1 = random.randint(0, ori_length - 1)
    random_number2 = random_number1
    while(random_number2 == random_number1):
        random_number2 = random.randint(0, ori_length - 1)

    shuffle_data_path1 = os.path.join(ori_data_path, ori_data_path_list[random_number1])
    shuffle_data_path2 = os.path.join(ori_data_path, ori_data_path_list[random_number2])
    shuffle_name_path1 = os.path.join(ori_name_path, ori_name_path_list[random_number1])
    shuffle_name_path2 = os.path.join(ori_name_path, ori_name_path_list[random_number2])

    data_check1 = torch.load(shuffle_data_path1)
    data_check2 = torch.load(shuffle_data_path2)
    name_check1 = torch.load(shuffle_name_path1)
    name_check2 = torch.load(shuffle_name_path2)


    image1 = data_check1['image_list']
    depth1 = data_check1['depth_list']
    image_name1 = name_check1['image_name']
    depth_name1  = name_check1['depth_name']
    # print(image_name1[:5])
    image2 = data_check2['image_list']
    depth2 = data_check2['depth_list']
    image_name2 = name_check2['image_name']
    depth_name2 = name_check2['depth_name']
    start = 0
    end = 4999
    num_samples = 5000
    random_list1 = random.sample(range(start, end + 1), num_samples)
    random_list2 = random.sample(range(start, end + 1), num_samples)

    image1_tmp = []
    for idx in random_list1:
        image1_tmp.append(image1[idx])
    image1 = image1_tmp
    del image1_tmp

    depth1_tmp = []
    for idx in random_list1:
        depth1_tmp.append(depth1[idx])
    depth1 = depth1_tmp
    del depth1_tmp

    image_name1_tmp = []
    for idx in random_list1:
        image_name1_tmp.append(image_name1[idx])
    image_name1 = image_name1_tmp
    del image_name1_tmp

    depth_name1_tmp = []
    for idx in random_list1:
        depth_name1_tmp.append(depth_name1[idx])
    depth_name1 = depth_name1_tmp
    del depth_name1_tmp

    image2_tmp = []
    for idx in random_list2:
        image2_tmp.append(image2[idx])
    image2 = image2_tmp
    image2_tmp = image2_tmp[:2500]

    depth2_tmp = []
    for idx in random_list2:
        depth2_tmp.append(depth2[idx])
    depth2 = depth2_tmp
    depth2_tmp = depth2_tmp[:2500]

    image_name2_tmp = []
    for idx in random_list2:
        image_name2_tmp.append(image_name2[idx])
    image_name2 = image_name2_tmp
    image_name2_tmp = image_name2_tmp[:2500]

    depth_name2_tmp = []
    for idx in random_list2:
        depth_name2_tmp.append(depth_name2[idx])
    depth_name2 = depth_name2_tmp
    depth_name2_tmp = depth_name2_tmp[:2500]

    image2[:2500] = image1[:2500]
    depth2[:2500] = depth1[:2500]
    depth_name2[:2500] = depth_name1[:2500]
    image_name2[:2500] = image_name1[:2500]

    image1[:2500] = image2_tmp
    depth1[:2500] = depth2_tmp
    image_name1[:2500] = image_name2_tmp
    depth_name1[:2500] = depth_name2_tmp

    print(len(image_name1))
    print(image_name1[-5:])


    # print(image_name1[:5])

    data_check1 = {
                'depth_list': depth1,
                'image_list' : image1,
            }
    name_check1 = {
                'depth_name' : depth_name1,
                'image_name' : image_name1
            }

    data_check2 = {
                'depth_list': depth2,
                'image_list' : image2,
            }
    name_check2 = {
                'depth_name' : depth_name2,
                'image_name' : image_name2
            }



    torch.save(data_check1, ori_data_path_list[random_number1])
    source_path = ori_data_path_list[random_number1]
    destination_path = ori_data_path
    shutil.copy(source_path, destination_path)


    torch.save(data_check2, ori_data_path_list[random_number2])
    source_path = ori_data_path_list[random_number2]
    destination_path = ori_data_path
    shutil.copy(source_path, destination_path)

    torch.save(name_check1, ori_name_path_list[random_number1])
    source_path = ori_name_path_list[random_number1]
    destination_path = ori_name_path
    shutil.copy(source_path, destination_path)

    torch.save(name_check2, ori_name_path_list[random_number2])
    source_path = ori_name_path_list[random_number2]
    destination_path = ori_name_path
    shutil.copy(source_path, destination_path)




    print(random_number1, random_number2)
end_time = time.time()
elapsed_time = end_time - start_time
print("代码段执行时间:", elapsed_time, "秒")
from google.colab import runtime
runtime.unassign()
'''

'''
# for finding the location where it breaked
path = '/content/drive/MyDrive/Colab Notebooks/Simple_DE/Data/Depth'
file = sorted(os.listdir(path))
for idx in range(len(file)):
  if file[idx] == '2011_09_28_drive_0184_sync':
    print(idx)

path = '/content/drive/MyDrive/Colab Notebooks/Simple_DE/Data/Depth/2011_09_28_drive_0184_sync/proj_depth/groundtruth'
file = sorted(os.listdir(path))
for idx in range(len(file)):
  if file[idx] == 'image_03':
    print(idx)

path = '/content/drive/MyDrive/Colab Notebooks/Simple_DE/Data/Depth/2011_09_28_drive_0184_sync/proj_depth/groundtruth/image_03'
file = sorted(os.listdir(path))
for idx in range(len(file)):
  if file[idx] == '0000000062.png':
    print(idx)
'''

def compute_depth_mean(path):
  file_list = sorted(os.listdir(path))
  total_sum = 0

  total_nonzero = 0
  # count = 0
  for name in file_list:
    file_path = path + '/' + name
    check = torch.load(file_path)

    target = torch.tensor(check['depth_list']).to(torch.float64)
    print(target.dtype)
    total_sum += torch.sum(target)

    total_nonzero += torch.nonzero(target).size(0)
    # count += 1
    # if count == 2:
    #   break
  total_mean = total_sum / total_nonzero
  return total_sum, total_nonzero, total_mean

def find_next_file(first, second):
  first_list = sorted(os.listdir(first))
  second_list = sorted(os.listdir(second))
  length = len(first_list)
  while True:
    rand_int = random.randint(0, length - 1)
    target = first_list[rand_int]
    if target in second_list:
      return first + '/' + target, second + '/' + target

def compute_depth_std(path, total_mean, total_nonzero):
  file_list = sorted(os.listdir(path))


  total_sum = 0
  # count = 0
  for name in file_list:
    file_path = path + '/' + name
    check = torch.load(file_path)

    target = torch.tensor(check['depth_list']).to(torch.float64)
    non_zero_mask = target != 0

    target = target[non_zero_mask]
    target = target - total_mean
    target = target ** 2
    target = target / (total_nonzero - 1)
    total_sum += torch.sum(target)


    # count += 1
    # if count == 2:
    #   break

  return total_sum

def create_dataset_large_epoch(random_list, now, data_path, name_path): #data_per_epoch / amount_from_file要是整數

  data_list = sorted(os.listdir(data_path))
  name_list = sorted(os.listdir(name_path))

  # file_idx = data_per_epoch // amount_from_file
  output_depth_path = []
  output_image_path = []
  output_depth = []
  output_image = []

  now_number = random_list[now]
  data_path = data_path + '/' + data_list[now_number]
  name_path = name_path + '/' + name_list[now_number]
  data_checkpoint = torch.load(data_path)
  name_checkpoint = torch.load(name_path)
  output_image_path = name_checkpoint['image_name']
  output_depth_path = name_checkpoint['depth_name']
  output_depth = data_checkpoint['depth_list']
  output_image = data_checkpoint['image_list']
  return output_image_path, output_depth_path, output_depth, output_image

class CustomDataset(Dataset):
    def __init__(self, img, depth):
        self.img = img
        self.depth = depth


    def __len__(self):
        return len(self.img)

    def __getitem__(self, idx):
        sample = {'img': self.img[idx], 'depth': self.depth[idx]}
        return sample

def image_loader_to_tensor(tensor):
  tensor = tensor.to(torch.float32)
  tensor = tensor / 255.0
  tensor = tensor * 2.0
  tensor = tensor - 1.0
  tensor = tensor.permute(0, 3, 1, 2)
  return tensor

def depth_loader_to_tensor(tensor, DEPTH_MEAN, DEPTH_STD):

  nonzero_mask = tensor != 0
  zero_mask = tensor == 0
  # mean = tensor[nonzero_mask].mean()
  # std = tensor[nonzero_mask].std()
  result = (tensor[nonzero_mask] - DEPTH_MEAN) / DEPTH_STD
  tensor[nonzero_mask] = result
  tensor[zero_mask] = -1

  return tensor

def tensor_to_depth(tensor, DEPTH_MEAN, DEPTH_STD):
    minus_mask = tensor == -1
    non_minus = tensor != -1
    result = tensor[non_minus] * DEPTH_STD + DEPTH_MEAN
    tensor[non_minus] = resalt
    tensor[minus_mask] = 0
    return tensor

# maybe needs change
def image_tensor_to_numpy(tensor):

    tensor = tensor.permute(0, 2, 3, 1)
    output = tensor.numpy()
    output = output + 1.0
    output = output / 2.0
    output = output * 255.0
    output = output.astype(np.uint8)

    return output